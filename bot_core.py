import os
import logging
import json
import asyncio
from datetime import datetime, timedelta
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.date import DateTrigger
from http.server import HTTPServer, BaseHTTPRequestHandler
import threading
import psycopg2
from psycopg2.extras import RealDictCursor
import psycopg2.pool
import socket

# ÈÖçÁΩÆÊó•Âøó
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ÁéØÂ¢ÉÂèòÈáè
TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
DATABASE_URL = os.getenv('DATABASE_URL')

# ÂÖ®Â±ÄËøûÊé•Ê±†ÂíåË∞ÉÂ∫¶Âô®
db_pool = None
scheduler = AsyncIOScheduler()

# Language texts
TEXTS = {
    'zh': {
        'welcome': 'üëã Ê≠°Ëøé‰ΩøÁî®ÂæÖËæ¶‰∫ãÈ†ÖÊ©üÂô®‰∫∫ÔºÅ\n‰ΩøÁî® /help Êü•ÁúãÂπ´Âä©',
        'choose_language': 'üåê Ë´ãÈÅ∏ÊìáË™ûË®ÄÔºö',
        'main_menu': 'üè† ‰∏ªÈÅ∏ÂñÆ - Ë´ãÈÅ∏ÊìáÊìç‰ΩúÔºö',
        'query_all': 'üìã ÊâÄÊúâÂæÖËæ¶‰∫ãÈ†Ö',
        'query_category': 'üîç ÂàÜÈ°ûÊü•Ë©¢',
        'add_todo': 'üìù Êñ∞Â¢ûÂæÖËæ¶',
        'delete_todo': 'üóëÔ∏è Âà™Èô§ÂæÖËæ¶',
        'change_language': 'üåê ÂàáÊèõË™ûË®Ä',
        'help': '‚ùì Âπ´Âä©',
        'choose_category': 'üìÇ Ë´ãÈÅ∏ÊìáÈ°ûÂà•Ôºö',
        'enter_task': '‚úèÔ∏è Ë´ãËº∏ÂÖ•ÂæÖËæ¶‰∫ãÈ†ÖÂÖßÂÆπÔºö',
        'need_reminder': '‚è∞ ÈúÄË¶ÅË®≠ÁΩÆÊèêÈÜíÂóéÔºü',
        'enter_reminder_time': 'üïí Ë´ãËº∏ÂÖ•ÊèêÈÜíÊôÇÈñìÔºàÊ†ºÂºèÔºöHH:MM Êàñ ÂπæÂ∞èÊôÇÂæåÔºâÔºö',
        'task_added': '‚úÖ Â∑≤ÊàêÂäüÊ∑ªÂä†ÂæÖËæ¶‰∫ãÈ†ÖÔºÅ',
        'no_tasks': 'üì≠ ÁõÆÂâçÊ≤íÊúâÂæÖËæ¶‰∫ãÈ†Ö',
        'tasks_in_category': 'üìã {}È°ûÂà•ÁöÑÂæÖËæ¶‰∫ãÈ†ÖÔºö',
        'all_tasks': 'üìã ÊâÄÊúâÂæÖËæ¶‰∫ãÈ†ÖÔºö',
        'reminder_set': '‚è∞ Â∑≤Ë®≠ÁΩÆÊèêÈÜíÊñº {}',
        'invalid_time': '‚ùå ÊôÇÈñìÊ†ºÂºèÈåØË™§ÔºåË´ã‰ΩøÁî® HH:MM Ê†ºÂºèÊàñ "XÂ∞èÊôÇÂæå"',
        'category_game': 'üéÆ ÈÅäÊà≤',
        'category_movie': 'üì∫ ÂΩ±Ë¶ñ',
        'category_action': '‚≠ê Ë°åÂãï',
        'choose_todo_delete': 'üóëÔ∏è Ë´ãÈÅ∏ÊìáË¶ÅÂà™Èô§ÁöÑÂæÖËæ¶‰∫ãÈ†ÖÔºö',
        'task_deleted': '‚úÖ Â∑≤Âà™Èô§ÂæÖËæ¶‰∫ãÈ†Ö',
        'help_text': 'üìñ Âπ´Âä©Ôºö\n- Êñ∞Â¢ûÂæÖËæ¶ÔºöÈÅ∏ÊìáÈ°ûÂà• > Ëº∏ÂÖ•ÂÖßÂÆπ > ÈÅ∏ÊìáÊòØÂê¶ÊèêÈÜí\n- Êü•Ë©¢ÔºöÊü•ÁúãÊâÄÊúâÊàñÊåâÈ°ûÂà•\n- Âà™Èô§ÔºöÈÅ∏ÊìáË¶ÅÂà™Èô§ÁöÑÈ†ÖÁõÆ\n- Ë™ûË®ÄÔºöÂàáÊèõ‰∏≠Ëã±'
    },
    'en': {
        'welcome': 'üëã Welcome to Todo Bot!\nUse /help for help',
        'choose_language': 'üåê Please choose language:',
        'main_menu': 'üè† Main Menu - Please choose operation:',
        'query_all': 'üìã All Todos',
        'query_category': 'üîç Query by Category',
        'add_todo': 'üìù Add Todo',
        'delete_todo': 'üóëÔ∏è Delete Todo',
        'change_language': 'üåê Change Language',
        'help': '‚ùì Help',
        'choose_category': 'üìÇ Please choose category:',
        'enter_task': '‚úèÔ∏è Please enter todo content:',
        'need_reminder': '‚è∞ Do you need a reminder?',
        'enter_reminder_time': 'üïí Please enter reminder time (format: HH:MM or in X hours):',
        'task_added': '‚úÖ Todo added successfully!',
        'no_tasks': 'üì≠ No tasks at the moment',
        'tasks_in_category': 'üìã Todos in {} category:',
        'all_tasks': 'üìã All todos:',
        'reminder_set': '‚è∞ Reminder set for {}',
        'invalid_time': '‚ùå Invalid time format, please use HH:MM or "in X hours"',
        'category_game': 'üéÆ Games',
        'category_movie': 'üì∫ Movies',
        'category_action': '‚≠ê Actions',
        'choose_todo_delete': 'üóëÔ∏è Please select todo to delete:',
        'task_deleted': '‚úÖ Todo deleted successfully',
        'help_text': 'üìñ Help:\n- Add Todo: Choose category > Enter content > Set reminder if needed\n- Query: View all or by category\n- Delete: Select item to delete\n- Language: Switch between EN/ZH'
    }
}

# Categories
CATEGORIES = {
    'game': {'zh': 'üéÆ ÈÅäÊà≤', 'en': 'üéÆ Games'},
    'movie': {'zh': 'üì∫ ÂΩ±Ë¶ñ', 'en': 'üì∫ Movies'},
    'action': {'zh': '‚≠ê Ë°åÂãï', 'en': '‚≠ê Actions'}
}

# ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ìËøûÊé•Ê±†
def init_db_pool():
    global db_pool
    try:
        db_pool = psycopg2.pool.SimpleConnectionPool(
            minconn=1,
            maxconn=10,
            dsn=DATABASE_URL,
            sslmode='require'
        )
        logger.info("Database connection pool initialized")
    except Exception as e:
        logger.critical(f"Database pool initialization failed: {e}")
        raise

def get_db_connection():
    global db_pool
    if db_pool is None:
        raise Exception("Database connection pool is not initialized")
    try:
        return db_pool.getconn()
    except Exception as e:
        logger.error(f"Error getting connection from pool: {e}")
        raise

def put_db_connection(conn):
    if conn:
        db_pool.putconn(conn)

def close_db_pool():
    global db_pool
    if db_pool:
        db_pool.closeall()
        logger.info("Database connection pool closed")

# Database functions
def init_db():
    conn = None
    try:
        conn = get_db_connection()
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS users
                     (user_id BIGINT PRIMARY KEY, 
                      language TEXT DEFAULT 'zh', 
                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
        c.execute('''CREATE TABLE IF NOT EXISTS todos
                     (id SERIAL PRIMARY KEY, 
                      user_id BIGINT, 
                      category TEXT,
                      task TEXT, 
                      reminder_time TIMESTAMP NULL,
                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                      FOREIGN KEY(user_id) REFERENCES users(user_id))''')
        conn.commit()
        logger.info("Database tables initialized successfully")
    except Exception as e:
        logger.critical(f"Database initialization failed: {e}")
        raise
    finally:
        put_db_connection(conn)

def get_user_language(user_id):
    conn = None
    try:
        conn = get_db_connection()
        c = conn.cursor()
        c.execute("SELECT language FROM users WHERE user_id = %s", (user_id,))
        result = c.fetchone()
        return result[0] if result else 'zh'
    except Exception as e:
        logger.error(f"Error getting user language: {e}")
        return 'zh'
    finally:
        put_db_connection(conn)

def set_user_language(user_id, language):
    conn = None
    try:
        conn = get_db_connection()
        c = conn.cursor()
        c.execute("""
            INSERT INTO users (user_id, language) 
            VALUES (%s, %s)
            ON CONFLICT (user_id) 
            DO UPDATE SET language = EXCLUDED.language
        """, (user_id, language))
        conn.commit()
    except Exception as e:
        logger.error(f"Error setting user language: {e}")
        raise
    finally:
        put_db_connection(conn)

def add_todo_to_db(user_id, category, task, reminder_time=None):
    conn = None
    try:
        conn = get_db_connection()
        c = conn.cursor()
        c.execute("""
            INSERT INTO users (user_id) 
            VALUES (%s)
            ON CONFLICT (user_id) DO NOTHING
        """, (user_id,))
        c.execute("""
            INSERT INTO todos (user_id, category, task, reminder_time) 
            VALUES (%s, %s, %s, %s)
            RETURNING id
        """, (user_id, category, task, reminder_time))
        todo_id = c.fetchone()[0]
        conn.commit()
        return todo_id
    except Exception as e:
        logger.error(f"Error adding todo: {e}")
        raise
    finally:
        put_db_connection(conn)

def get_todos(user_id, category=None):
    conn = None
    try:
        conn = get_db_connection()
        c = conn.cursor()
        if category:
            c.execute("""
                SELECT id, category, task, reminder_time 
                FROM todos 
                WHERE user_id = %s AND category = %s 
                ORDER BY created_at
            """, (user_id, category))
        else:
            c.execute("""
                SELECT id, category, task, reminder_time 
                FROM todos 
                WHERE user_id = %s 
                ORDER BY created_at
            """, (user_id,))
        todos = c.fetchall()
        return todos
    except Exception as e:
        logger.error(f"Error getting todos: {e}")
        return []
    finally:
        put_db_connection(conn)

def delete_todo(user_id, todo_id):
    conn = None
    try:
        conn = get_db_connection()
        c = conn.cursor()
        c.execute("""
            DELETE FROM todos 
            WHERE user_id = %s AND id = %s
        """, (user_id, todo_id))
        conn.commit()
        return c.rowcount > 0
    except Exception as e:
        logger.error(f"Error deleting todo: {e}")
        return False
    finally:
        put_db_connection(conn)

# Keyboard functions
def get_main_keyboard(language):
    text = TEXTS[language]
    return ReplyKeyboardMarkup([
        [text['query_all'], text['query_category']],
        [text['add_todo'], text['delete_todo']],
        [text['change_language'], text['help']]
    ], resize_keyboard=True, one_time_keyboard=False)

def get_category_keyboard(language, operation_type):
    keyboard = []
    for category_id, category_names in CATEGORIES.items():
        keyboard.append([InlineKeyboardButton(category_names[language], callback_data=f'{operation_type}_category_{category_id}')])
    return InlineKeyboardMarkup(keyboard)

def get_reminder_keyboard(language):
    text = TEXTS[language]
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("‚úÖ " + ("ÊòØ" if language == 'zh' else "Yes"), callback_data='reminder_yes'),
         InlineKeyboardButton("‚ùå " + ("Âê¶" if language == 'zh' else "No"), callback_data='reminder_no')]
    ])

def get_language_keyboard():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üá®üá≥ ‰∏≠Êñá", callback_data='lang_zh'),
         InlineKeyboardButton("üá¨üáß ENG", callback_data='lang_en')]
    ])

def get_delete_keyboard(language, todos):
    keyboard = []
    for todo_id, _, task, _ in todos:
        keyboard.append([InlineKeyboardButton(f"{task[:20]}...", callback_data=f'delete_{todo_id}')])
    return InlineKeyboardMarkup(keyboard)

# Time parsing function
def parse_reminder_time(time_str, language):
    try:
        time_str = time_str.lower().strip()
        if ':' in time_str:
            hours, minutes = map(int, time_str.split(':'))
            now = datetime.now()
            reminder_time = now.replace(hour=hours, minute=minutes, second=0, microsecond=0)
            if reminder_time < now:
                reminder_time += timedelta(days=1)
            return reminder_time
        if language == 'en':
            if 'hour' in time_str or 'hours' in time_str:
                hours = int(''.join(filter(str.isdigit, time_str)))
                return datetime.now() + timedelta(hours=hours)
        elif language == 'zh':
            if 'Â∞èÊôÇ' in time_str or 'Â∞èÊó∂' in time_str or 'Âæå' in time_str or 'Âêé' in time_str:
                hours = int(''.join(filter(str.isdigit, time_str)))
                return datetime.now() + timedelta(hours=hours)
    except (ValueError, AttributeError):
        pass
    return None

# Handlers
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    language = get_user_language(user_id)
    text = TEXTS[language]
    await update.message.reply_text(
        text['welcome'],
        reply_markup=get_main_keyboard(language)
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    language = get_user_language(user_id)
    text = TEXTS[language]
    await update.message.reply_text(
        text['help_text'],
        reply_markup=get_main_keyboard(language)
    )

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    language = get_user_language(user_id)
    text = TEXTS[language]
    context.user_data.clear()
    await update.message.reply_text(
        text['welcome'],
        reply_markup=get_main_keyboard(language)
    )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    language = get_user_language(user_id)
    text = TEXTS[language]
    message_text = update.message.text

    if message_text == text['query_all']:
        await query_all_todos(update, context)
    elif message_text == text['query_category']:
        await choose_category(update, context, 'query')
    elif message_text == text['add_todo']:
        await choose_category(update, context, 'add')
    elif message_text == text['delete_todo']:
        await choose_delete(update, context)
    elif message_text == text['change_language']:
        await change_language(update, context)
    elif message_text == text['help']:
        await help_command(update, context)
    else:
        if 'waiting_task' in context.user_data:
            context.user_data['waiting_task'] = message_text
            await update.message.reply_text(
                text['need_reminder'],
                reply_markup=get_reminder_keyboard(language)
            )
        elif 'waiting_reminder_time' in context.user_data:
            reminder_time = parse_reminder_time(message_text, language)
            if reminder_time:
                category = context.user_data['waiting_category']
                task = context.user_data['waiting_task']
                todo_id = add_todo_to_db(user_id, category, task, reminder_time)
                await schedule_reminder(user_id, task, reminder_time, todo_id, context)
                await update.message.reply_text(
                    text['reminder_set'].format(reminder_time.strftime('%Y-%m-%d %H:%M')),
                    reply_markup=get_main_keyboard(language)
                )
                context.user_data.clear()
            else:
                await update.message.reply_text(
                    text['invalid_time'] + '\n' + text['enter_reminder_time']
                )

async def callback_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    language = get_user_language(user_id)
    text = TEXTS[language]
    data = query.data

    if data.startswith('lang_'):
        new_language = data.split('_')[1]
        set_user_language(user_id, new_language)
        await query.edit_message_text(f"‚úÖ Language changed to {new_language.upper()}")
        await context.bot.send_message(
            chat_id=query.message.chat_id,
            text=TEXTS[new_language]['welcome'],
            reply_markup=get_main_keyboard(new_language)
        )
    elif data.startswith('add_category_'):
        category = data.split('_')[2]
        context.user_data['waiting_category'] = category
        context.user_data['waiting_task'] = True
        await query.edit_message_text(text['enter_task'])
    elif data.startswith('query_category_'):
        category = data.split('_')[2]
        await show_todos_by_category(query, context, category)
    elif data.startswith('reminder_'):
        if 'waiting_task' not in context.user_data or 'waiting_category' not in context.user_data:
            await query.edit_message_text("‚ùå Êìç‰ΩúÂ∑≤ÈÅéÊúüÔºåË´ãÈáçÊñ∞ÈñãÂßã")
            return
        if data == 'reminder_yes':
            await query.edit_message_text(text['enter_reminder_time'])
            context.user_data['waiting_reminder_time'] = True
        else:
            category = context.user_data['waiting_category']
            task = context.user_data['waiting_task']
            add_todo_to_db(user_id, category, task)
            await query.edit_message_text(text['task_added'])
            await context.bot.send_message(
                chat_id=query.message.chat_id,
                reply_markup=get_main_keyboard(language)
            )
            context.user_data.clear()
    elif data.startswith('delete_'):
        todo_id = int(data.split('_')[1])
        if delete_todo(user_id, todo_id):
            await query.edit_message_text(text['task_deleted'])
        else:
            await query.edit_message_text("‚ùå Âà™Èô§Â§±Êïó")
        await context.bot.send_message(
            chat_id=query.message.chat_id,
            reply_markup=get_main_keyboard(language)
        )

async def choose_category(update: Update, context: ContextTypes.DEFAULT_TYPE, operation_type):
    user_id = update.message.from_user.id
    language = get_user_language(user_id)
    text = TEXTS[language]
    await update.message.reply_text(
        text['choose_category'],
        reply_markup=get_category_keyboard(language, operation_type)
    )

async def query_all_todos(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    language = get_user_language(user_id)
    text = TEXTS[language]
    todos = get_todos(user_id)
    if not todos:
        await update.message.reply_text(text['no_tasks'])
        return
    message = text['all_tasks'] + '\n\n'
    for i, (_, category, task, reminder_time) in enumerate(todos, 1):
        category_name = CATEGORIES[category][language]
        reminder_text = f" ‚è∞ {reminder_time.strftime('%Y-%m-%d %H:%M')}" if reminder_time else ""
        message += f"{i}. {category_name}: {task}{reminder_text}\n"
    await update.message.reply_text(message, reply_markup=get_main_keyboard(language))

async def show_todos_by_category(query, context: ContextTypes.DEFAULT_TYPE, category):
    user_id = query.from_user.id
    language = get_user_language(user_id)
    text = TEXTS[language]
    todos = get_todos(user_id, category)
    if not todos:
        await query.edit_message_text(text['no_tasks'])
        return
    category_name = CATEGORIES[category][language]
    message = text['tasks_in_category'].format(category_name) + '\n\n'
    for i, (_, _, task, reminder_time) in enumerate(todos, 1):
        reminder_text = f" ‚è∞ {reminder_time.strftime('%Y-%m-%d %H:%M')}" if reminder_time else ""
        message += f"{i}. {task}{reminder_text}\n"
    await query.edit_message_text(message)

async def choose_delete(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    language = get_user_language(user_id)
    text = TEXTS[language]
    todos = get_todos(user_id)
    if not todos:
        await update.message.reply_text(text['no_tasks'])
        return
    await update.message.reply_text(
        text['choose_todo_delete'],
        reply_markup=get_delete_keyboard(language, todos)
    )

async def change_language(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "üåê Ë´ãÈÅ∏ÊìáË™ûË®Ä / Please choose language:",
        reply_markup=get_language_keyboard()
    )

async def schedule_reminder(user_id, task, reminder_time, todo_id, context):
    async def send_reminder():
        try:
            language = get_user_language(user_id)
            await context.bot.send_message(
                chat_id=user_id,
                text=f"‚è∞ ÊèêÈÜí: {task}"
            )
        except Exception as e:
            logger.error(f"Failed to send reminder for todo_id {todo_id}: {e}")
    scheduler.add_job(
        send_reminder,
        trigger=DateTrigger(run_date=reminder_time),
        id=f"reminder_{todo_id}_{user_id}"
    )

# ÂÅ•Â∫∑Ê£ÄÊü•ÊúçÂä°Âô®
class HealthCheckHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        logger.info(f"Received health check request: {self.path}")
        if self.path in ['/', '/health']:
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            response = json.dumps({"status": "ok", "service": "telegram-todo-bot"})
            self.wfile.write(response.encode('utf-8'))
        else:
            self.send_response(404)
            self.end_headers()
    
    def do_HEAD(self):
        logger.info(f"Received health check HEAD request: {self.path}")
        if self.path in ['/', '/health']:
            self.send_response(200)
            self.end_headers()
        else:
            self.send_response(404)
            self.end_headers()

def is_port_available(port):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        return s.connect_ex(('0.0.0.0', port)) != 0

def run_health_server():
    port = 10000
    if not is_port_available(port):
        logger.error(f"Port {port} is already in use")
        return
    server = HTTPServer(('0.0.0.0', port), HealthCheckHandler)
    logger.info(f"Health check server started on port {port}")
    server.serve_forever()

def check_env_vars():
    if not TOKEN:
        raise ValueError("TELEGRAM_BOT_TOKEN environment variable not set")
    if not DATABASE_URL:
        raise ValueError("DATABASE_URL environment variable not set")

async def main():
    application = None
    try:
        check_env_vars()
        init_db_pool()
        init_db()
        scheduler.start()
        health_thread = threading.Thread(target=run_health_server, daemon=True)
        health_thread.start()
        
        application = Application.builder().token(TOKEN).build()
        application.add_handler(CommandHandler("start", start))
        application.add_handler(CommandHandler("help", help_command))
        application.add_handler(CommandHandler("cancel", cancel))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
        application.add_handler(CallbackQueryHandler(callback_query))
        
        logger.info("Starting bot with polling mode...")
        await application.bot.delete_webhook(drop_pending_updates=True)
        await application.run_polling()
    except Exception as e:
        logger.error(f"Bot startup failed: {e}")
        if application:
            await application.shutdown()
        raise
    finally:
        scheduler.shutdown()
        close_db_pool()

if __name__ == '__main__':
    loop = asyncio.get_event_loop_policy().get_event_loop()
    loop.run_until_complete(main())