import os
import logging
import asyncio
from datetime import datetime, timedelta
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters
import psycopg2
import psycopg2.pool

# ÈÖçÁΩÆÊó•Âøó
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ÁéØÂ¢ÉÂèòÈáè
TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
DATABASE_URL = os.getenv('DATABASE_URL')

# ÂÖ®Â±ÄËøûÊé•Ê±†
db_pool = None

# Âè™‰øùÁïôÁπÅ‰Ωì‰∏≠ÊñáÊñáÊú¨
TEXTS = {
    'welcome': 'üëã Ê≠°Ëøé‰ΩøÁî®ÂæÖËæ¶‰∫ãÈ†ÖÊ©üÂô®‰∫∫ÔºÅ\n‰ΩøÁî® /help Êü•ÁúãÂπ´Âä©',
    'main_menu': 'üè† ‰∏ªÈÅ∏ÂñÆ - Ë´ãÈÅ∏ÊìáÊìç‰ΩúÔºö',
    'query_all': 'üìã ÊâÄÊúâÂæÖËæ¶‰∫ãÈ†Ö',
    'query_category': 'üîç ÂàÜÈ°ûÊü•Ë©¢',
    'add_todo': 'üìù Êñ∞Â¢ûÂæÖËæ¶',
    'delete_todo': 'üóëÔ∏è Âà™Èô§ÂæÖËæ¶',
    'help': '‚ùì Âπ´Âä©',
    'choose_category': 'üìÇ Ë´ãÈÅ∏ÊìáÈ°ûÂà•Ôºö',
    'enter_task': '‚úèÔ∏è Ë´ãËº∏ÂÖ•ÂæÖËæ¶‰∫ãÈ†ÖÂÖßÂÆπÔºö',
    'need_reminder': '‚è∞ ÈúÄË¶ÅË®≠ÁΩÆÊèêÈÜíÂóéÔºü',
    'enter_reminder_time': 'üïí Ë´ãËº∏ÂÖ•ÊèêÈÜíÊôÇÈñìÔºàÊ†ºÂºèÔºöHH:MMÔºâÔºö',
    'task_added': '‚úÖ Â∑≤ÊàêÂäüÊ∑ªÂä†ÂæÖËæ¶‰∫ãÈ†ÖÔºÅ',
    'no_tasks': 'üì≠ ÁõÆÂâçÊ≤íÊúâÂæÖËæ¶‰∫ãÈ†Ö',
    'tasks_in_category': 'üìã {}È°ûÂà•ÁöÑÂæÖËæ¶‰∫ãÈ†ÖÔºö',
    'all_tasks': 'üìã ÊâÄÊúâÂæÖËæ¶‰∫ãÈ†ÖÔºö',
    'invalid_time': '‚ùå ÊôÇÈñìÊ†ºÂºèÈåØË™§ÔºåË´ã‰ΩøÁî® HH:MM Ê†ºÂºè',
    'category_game': 'üéÆ ÈÅäÊà≤',
    'category_movie': 'üì∫ ÂΩ±Ë¶ñ',
    'category_action': '‚≠ê Ë°åÂãï',
    'choose_todo_delete': 'üóëÔ∏è Ë´ãÈÅ∏ÊìáË¶ÅÂà™Èô§ÁöÑÂæÖËæ¶‰∫ãÈ†ÖÔºö',
    'task_deleted': '‚úÖ Â∑≤Âà™Èô§ÂæÖËæ¶‰∫ãÈ†Ö',
    'help_text': 'üìñ Âπ´Âä©Ôºö\n- Êñ∞Â¢ûÂæÖËæ¶ÔºöÈÅ∏ÊìáÈ°ûÂà• > Ëº∏ÂÖ•ÂÖßÂÆπ\n- Êü•Ë©¢ÔºöÊü•ÁúãÊâÄÊúâÊàñÊåâÈ°ûÂà•\n- Âà™Èô§ÔºöÈÅ∏ÊìáË¶ÅÂà™Èô§ÁöÑÈ†ÖÁõÆ'
}

# Categories
CATEGORIES = {
    'game': 'üéÆ ÈÅäÊà≤',
    'movie': 'üì∫ ÂΩ±Ë¶ñ',
    'action': '‚≠ê Ë°åÂãï'
}

# ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ìËøûÊé•Ê±†
def init_db_pool():
    global db_pool
    try:
        db_pool = psycopg2.pool.SimpleConnectionPool(
            minconn=1,
            maxconn=10,
            dsn=DATABASE_URL,
            sslmode='require'
        )
        logger.info("Database connection pool initialized")
    except Exception as e:
        logger.critical(f"Database pool initialization failed: {e}")
        raise

def get_db_connection():
    global db_pool
    if db_pool is None:
        raise Exception("Database connection pool is not initialized")
    try:
        return db_pool.getconn()
    except Exception as e:
        logger.error(f"Error getting connection from pool: {e}")
        raise

def put_db_connection(conn):
    if conn:
        db_pool.putconn(conn)

def close_db_pool():
    global db_pool
    if db_pool:
        db_pool.closeall()
        logger.info("Database connection pool closed")

# Database functions
def init_db():
    conn = None
    try:
        conn = get_db_connection()
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS users
                     (user_id BIGINT PRIMARY KEY,
                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
        c.execute('''CREATE TABLE IF NOT EXISTS todos
                     (id SERIAL PRIMARY KEY,
                      user_id BIGINT,
                      category TEXT,
                      task TEXT,
                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                      FOREIGN KEY(user_id) REFERENCES users(user_id))''')
        conn.commit()
        logger.info("Database tables initialized successfully")
    except Exception as e:
        logger.critical(f"Database initialization failed: {e}")
        raise
    finally:
        put_db_connection(conn)

def add_todo_to_db(user_id, category, task):
    conn = None
    try:
        conn = get_db_connection()
        c = conn.cursor()
        c.execute("""
            INSERT INTO users (user_id)
            VALUES (%s)
            ON CONFLICT (user_id) DO NOTHING
        """, (user_id,))
        c.execute("""
            INSERT INTO todos (user_id, category, task)
            VALUES (%s, %s, %s)
            RETURNING id
        """, (user_id, category, task))
        todo_id = c.fetchone()[0]
        conn.commit()
        return todo_id
    except Exception as e:
        logger.error(f"Error adding todo: {e}")
        raise
    finally:
        put_db_connection(conn)

def get_todos(user_id, category=None):
    conn = None
    try:
        conn = get_db_connection()
        c = conn.cursor()
        if category:
            c.execute("""
                SELECT id, category, task
                FROM todos
                WHERE user_id = %s AND category = %s
                ORDER BY created_at
            """, (user_id, category))
        else:
            c.execute("""
                SELECT id, category, task
                FROM todos
                WHERE user_id = %s
                ORDER BY created_at
            """, (user_id,))
        todos = c.fetchall()
        return todos
    except Exception as e:
        logger.error(f"Error getting todos: {e}")
        return []
    finally:
        put_db_connection(conn)

def delete_todo(user_id, todo_id):
    conn = None
    try:
        conn = get_db_connection()
        c = conn.cursor()
        c.execute("""
            DELETE FROM todos
            WHERE user_id = %s AND id = %s
        """, (user_id, todo_id))
        conn.commit()
        return c.rowcount > 0
    except Exception as e:
        logger.error(f"Error deleting todo: {e}")
        return False
    finally:
        put_db_connection(conn)

# Keyboard functions
def get_main_keyboard():
    return ReplyKeyboardMarkup([
        [TEXTS['query_all'], TEXTS['query_category']],
        [TEXTS['add_todo'], TEXTS['delete_todo']],
        [TEXTS['help']]
    ], resize_keyboard=True, one_time_keyboard=False)

def get_category_keyboard(operation_type):
    keyboard = []
    for category_id, category_name in CATEGORIES.items():
        keyboard.append([InlineKeyboardButton(category_name, callback_data=f'{operation_type}_category_{category_id}')])
    return InlineKeyboardMarkup(keyboard)

def get_delete_keyboard(todos):
    keyboard = []
    for todo_id, _, task in todos:
        keyboard.append([InlineKeyboardButton(f"{task[:20]}...", callback_data=f'delete_{todo_id}')])
    return InlineKeyboardMarkup(keyboard)

# Handlers
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        TEXTS['welcome'],
        reply_markup=get_main_keyboard()
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        TEXTS['help_text'],
        reply_markup=get_main_keyboard()
    )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    message_text = update.message.text

    if message_text == TEXTS['query_all']:
        await query_all_todos(update, context)
    elif message_text == TEXTS['query_category']:
        await choose_category(update, context, 'query')
    elif message_text == TEXTS['add_todo']:
        await choose_category(update, context, 'add')
    elif message_text == TEXTS['delete_todo']:
        await choose_delete(update, context)
    elif message_text == TEXTS['help']:
        await help_command(update, context)
    else:
        if 'waiting_task' in context.user_data:
            category = context.user_data['waiting_category']
            task = message_text
            add_todo_to_db(user_id, category, task)
            await update.message.reply_text(
                TEXTS['task_added'],
                reply_markup=get_main_keyboard()
            )
            context.user_data.clear()

async def callback_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    data = query.data

    if data.startswith('add_category_'):
        category = data.split('_')[2]
        context.user_data['waiting_category'] = category
        context.user_data['waiting_task'] = True
        await query.edit_message_text(TEXTS['enter_task'])
    elif data.startswith('query_category_'):
        category = data.split('_')[2]
        await show_todos_by_category(query, context, category)
    elif data.startswith('delete_'):
        todo_id = int(data.split('_')[1])
        if delete_todo(user_id, todo_id):
            await query.edit_message_text(TEXTS['task_deleted'])
        else:
            await query.edit_message_text("‚ùå Âà™Èô§Â§±Êïó")
        await context.bot.send_message(
            chat_id=query.message.chat_id,
            reply_markup=get_main_keyboard()
        )

async def choose_category(update: Update, context: ContextTypes.DEFAULT_TYPE, operation_type):
    await update.message.reply_text(
        TEXTS['choose_category'],
        reply_markup=get_category_keyboard(operation_type)
    )

async def query_all_todos(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    todos = get_todos(user_id)
    if not todos:
        await update.message.reply_text(TEXTS['no_tasks'])
        return
    message = TEXTS['all_tasks'] + '\n\n'
    for i, (_, category, task) in enumerate(todos, 1):
        category_name = CATEGORIES[category]
        message += f"{i}. {category_name}: {task}\n"
    await update.message.reply_text(message, reply_markup=get_main_keyboard())

async def show_todos_by_category(query, context: ContextTypes.DEFAULT_TYPE, category):
    user_id = query.from_user.id
    todos = get_todos(user_id, category)
    if not todos:
        await query.edit_message_text(TEXTS['no_tasks'])
        return
    category_name = CATEGORIES[category]
    message = TEXTS['tasks_in_category'].format(category_name) + '\n\n'
    for i, (_, _, task) in enumerate(todos, 1):
        message += f"{i}. {task}\n"
    await query.edit_message_text(message)

async def choose_delete(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    todos = get_todos(user_id)
    if not todos:
        await update.message.reply_text(TEXTS['no_tasks'])
        return
    await update.message.reply_text(
        TEXTS['choose_todo_delete'],
        reply_markup=get_delete_keyboard(todos)
    )

def check_env_vars():
    if not TOKEN:
        raise ValueError("TELEGRAM_BOT_TOKEN environment variable not set")
    if not DATABASE_URL:
        raise ValueError("DATABASE_URL environment variable not set")

def main():
    application = None
    try:
        check_env_vars()
        init_db_pool()
        init_db()

        application = Application.builder().token(TOKEN).build()
        application.add_handler(CommandHandler("start", start))
        application.add_handler(CommandHandler("help", help_command))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
        application.add_handler(CallbackQueryHandler(callback_query))

        logger.info("Starting bot with polling mode...")

        # ‰ΩøÁî®ÂêåÊ≠•ÁöÑ run_polling ÊñπÊ≥ï
        application.run_polling()

    except Exception as e:
        logger.error(f"Bot startup failed: {e}")
        raise
    finally:
        close_db_pool()

if __name__ == '__main__':
    # Áõ¥Êé•Ë™øÁî®ÂêåÊ≠•ÁöÑ main ÂáΩÊï∏
    main()

